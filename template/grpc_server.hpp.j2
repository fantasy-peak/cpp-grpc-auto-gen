// -----------------------------------------------------------------------------
//  @file    : {{grpc.out_server_file | get_filename }}
//  @details : Generated by cpp-grpc-auto-gen {{grpc.version}}.
//             https://github.com/fantasy-peak/cpp-grpc-auto-gen
//
//  @author  : fantasy-peak
//  @license : MIT License (see License file)
//  @copyright Copyright (c) 2025, fantasy-peak
// -----------------------------------------------------------------------------


#pragma once

#include <functional>
#include <memory>
#include <thread>
#include <utility>
#include <vector>
#include <optional>

#ifdef AGRPC_BOOST_ASIO
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/experimental/awaitable_operators.hpp>
#include <boost/asio/experimental/concurrent_channel.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/detail/error_code.hpp>
#else
#include <asio.hpp>
#include <asio/awaitable.hpp>
#include <asio/detached.hpp>
#include <asio/experimental/awaitable_operators.hpp>
#include <asio/experimental/concurrent_channel.hpp>
#include <asio/post.hpp>
#include <asio/use_awaitable.hpp>
#include <system/detail/error_code.hpp>
#endif

{% for name in grpc.include_grpc_files -%}
#include <{{ name }}>
{% endfor -%}
#include <health.grpc.pb.h>
#include <health.pb.h>

#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#ifdef OPEN_GRPC_REFLECTION_PLUGIN
#include <grpcpp/ext/proto_server_reflection_plugin.h>
#endif
#include <agrpc/asio_grpc.hpp>
#include <agrpc/health_check_service.hpp>

namespace {{grpc.namespace}} {

#ifdef AGRPC_BOOST_ASIO
namespace asio = boost::asio;
#endif

struct {{grpc.server_class_name}}Config {
    std::string addr_uri;
    int32_t thread_count{2};
    std::optional<int32_t> keepalive_time_ms;
    std::optional<int32_t> keepalive_timeout_ms;
    std::optional<int32_t> keepalive_permit_without_calls;
    std::optional<int32_t> http2_max_pings_without_data;
    std::optional<int32_t> http2_min_sent_ping_interval_without_data_ms;
    std::optional<int32_t> http2_min_recv_ping_interval_without_data_ms;
    bool enable_grpc_health_check{true};
};

{% for service_name in grpc.interface -%}
{% for interface in grpc.interface[service_name] -%}
using {{service_name}}{{interface.name}}RPC = agrpc::ServerRPC<&{{grpc.package}}::{{service_name}}::AsyncService::Request{{interface.name}}>;
{% endfor -%}
{% endfor -%}

/*************************************************** */
#if USE_GRPC_NOTIFY_WHEN_DONE
struct {{grpc.server_class_name}}ServerRPCNotifyWhenDoneTraits : agrpc::DefaultServerRPCTraits {
    static constexpr bool NOTIFY_WHEN_DONE = true;
};

{% for service_name in grpc.interface %}
{% for interface in grpc.interface[service_name] %}
{% if interface.type=='server-streaming-rpc' %}
using {{service_name}}{{interface.name}}NotifyWhenDoneRPC = agrpc::ServerRPC<&{{grpc.package}}::{{service_name}}::AsyncService::Request{{interface.name}}, {{grpc.server_class_name}}ServerRPCNotifyWhenDoneTraits>;
{% else -%}

{% endif -%}
{% endfor %}
{% endfor %}
#endif
/*************************************************** */

class {{grpc.server_class_name}} final {
public:
    {{grpc.server_class_name}}({{grpc.server_class_name}}Config config)
        : m_config(std::move(config)) {
    }
    ~{{grpc.server_class_name}}() {stop();}

    {{grpc.server_class_name}}(const {{grpc.server_class_name}}&) = delete;
    {{grpc.server_class_name}}& operator=(const {{grpc.server_class_name}}&) = delete;
    {{grpc.server_class_name}}({{grpc.server_class_name}}&&) = delete;
    {{grpc.server_class_name}}& operator=({{grpc.server_class_name}}&&) = delete;

    static auto create({{grpc.server_class_name}}Config config) {
        return std::make_unique<{{grpc.server_class_name}}>(std::move(config));
    }

    static consteval std::string_view extractFilename(const char* path) {
        std::string_view path_view{path};
        std::size_t last_slash = path_view.find_last_of("/\\");
        return (last_slash == std::string_view::npos)
                   ? path_view
                   : path_view.substr(last_slash + 1);
    }

    void start() {
        checkCallback();
        grpc::ServerBuilder builder;
        for (int i = 0; i < m_config.thread_count; i++) {
            m_grpc_contexts.emplace_back(std::make_shared<agrpc::GrpcContext>(builder.AddCompletionQueue()));
        }
        auto creds = grpc::InsecureServerCredentials();
        if (m_create_server_credentials)
            creds = m_create_server_credentials();
        builder.AddListeningPort(m_config.addr_uri, creds);
#ifdef OPEN_GRPC_REFLECTION_PLUGIN
        m_log(LogLevel::Info, extractFilename(__FILE__), __LINE__, "call InitProtoReflectionServerBuilderPlugin");
        grpc::reflection::InitProtoReflectionServerBuilderPlugin();
#endif
        {% for service_name in grpc.interface -%}
        m_{{service_name|to_snake}}_svc = std::make_unique<{{grpc.package}}::{{service_name}}::AsyncService>();
        builder.RegisterService(m_{{service_name|to_snake}}_svc.get());
        {% endfor %}

        // https://stackoverflow.com/questions/64297617/grpc-c-how-to-detect-client-disconnected-in-async-server
        // keepalive
        auto add_channel_argument = [&] (auto argument, auto& data) {
            if (data.has_value()) {
                m_log(LogLevel::Debug, extractFilename(__FILE__), __LINE__, std::string{argument} + "[" + std::to_string(data.value()) + "]");
                builder.AddChannelArgument(argument, data.value());
            }
        };
        add_channel_argument(GRPC_ARG_KEEPALIVE_TIME_MS, m_config.keepalive_time_ms);
        add_channel_argument(GRPC_ARG_KEEPALIVE_TIMEOUT_MS, m_config.keepalive_timeout_ms);
        add_channel_argument(GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS, m_config.keepalive_permit_without_calls);
        add_channel_argument(GRPC_ARG_HTTP2_MAX_PINGS_WITHOUT_DATA, m_config.http2_max_pings_without_data);
        add_channel_argument(GRPC_ARG_HTTP2_MIN_SENT_PING_INTERVAL_WITHOUT_DATA_MS, m_config.http2_min_sent_ping_interval_without_data_ms);
        add_channel_argument(GRPC_ARG_HTTP2_MIN_RECV_PING_INTERVAL_WITHOUT_DATA_MS, m_config.http2_min_recv_ping_interval_without_data_ms);
        if (m_add_channel_argument)
            m_add_channel_argument(builder);

        if (m_config.enable_grpc_health_check) {
            agrpc::add_health_check_service(builder);
            m_server_ptr = builder.BuildAndStart();
            m_log(LogLevel::Info, extractFilename(__FILE__), __LINE__, "start_health_check_service");
            agrpc::start_health_check_service(*m_server_ptr, *m_grpc_contexts[0]);
        } else {
            m_server_ptr = builder.BuildAndStart();
        }
        for (int32_t i = 0; i < m_config.thread_count; ++i) {
            m_threads.emplace_back([this, i] {
                auto& grpc_context = *m_grpc_contexts[i];
                registerHandler(grpc_context);
                grpc_context.run();
            });
        }
    }

    void stop() {
        if (m_grpc_contexts.empty())
            return;
        asio::post(*m_grpc_contexts[0], [&] { m_server_ptr->Shutdown(); });
        for (auto& thread : m_threads)
            thread.join();
        m_grpc_contexts.clear();
        m_threads.clear();
    }

    void setCreateSslServerCredentialsCallback(auto cb) {
        m_create_server_credentials = std::move(cb);
    }

    void setAddChannelArgumentCallback(auto cb) {
        m_add_channel_argument = std::move(cb);
    }

    void setLogCallback(auto cb) {
        m_log = std::move(cb);
    }

    {% for service_name in grpc.interface -%}
    {% for interface in grpc.interface[service_name] -%}
    void set{{service_name}}{{interface.name}}RpcCallback(auto cb) {
        m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler = std::move(cb);
    }
    {% endfor -%}
    {% endfor %}


#if USE_GRPC_NOTIFY_WHEN_DONE
    {% for service_name in grpc.interface %}
    {%- for interface in grpc.interface[service_name] -%}
    {%- if interface.type=='server-streaming-rpc' -%}
    void set{{service_name}}{{interface.name}}NotifyWhenDoneRpcCallback(auto cb) {
        m_{{service_name|to_snake}}_{{interface.name|to_snake}}_notify_when_done_rpc_handler = std::move(cb);
    }
    {%- else -%}
    {%- endif -%}
    {%- endfor -%}
    {% endfor %}
#endif

    enum class LogLevel : uint8_t {
        Debug,
        Info,
        Error,
    };

    static std::string_view toString(LogLevel log_level) {
        switch (log_level) {
            case LogLevel::Debug:
                return "Debug";
            case LogLevel::Info:
                return "Info";
            case LogLevel::Error:
                return "Error";
            default:
                return "Unknown";
        }
    }

private:
    struct RethrowFirstArg {
        template <class... T>
        void operator()(std::exception_ptr ep, T&&...) {
            if (ep) {
                std::rethrow_exception(ep);
            }
        }

        template <class... T>
        void operator()(T&&...) {
        }
    };

    void checkCallback() {
#if USE_GRPC_NOTIFY_WHEN_DONE
        {%- for service_name in grpc.interface -%}
        {% for interface in grpc.interface[service_name] %}
        {% if interface.type=='server-streaming-rpc' -%}
            if (!m_{{service_name|to_snake}}_{{interface.name|to_snake}}_notify_when_done_rpc_handler)
                throw std::runtime_error("not call set{{service_name}}{{interface.name}}NotifyWhenDoneRpcCallback");
        {%- else -%}
            if (!m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler)
                throw std::runtime_error("not call set{{service_name}}{{interface.name}}RpcCallback");
        {%- endif -%}
        {% endfor %}
        {% endfor -%}
#else
        {% for service_name in grpc.interface -%}
        {% for interface in grpc.interface[service_name] -%}
            if (!m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler)
                throw std::runtime_error("not call set{{service_name}}{{interface.name}}RpcCallback");
        {% endfor -%}
        {% endfor -%}
#endif
    }

    void registerHandler(auto& grpc_context) {
#if USE_GRPC_NOTIFY_WHEN_DONE
        {%- for service_name in grpc.interface -%}
        {%- for interface in grpc.interface[service_name] -%}
        {% if interface.type=='server-streaming-rpc' %}

        agrpc::register_awaitable_rpc_handler<
            {{service_name}}{{interface.name}}NotifyWhenDoneRPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_svc,
            [this]({{service_name}}{{interface.name}}NotifyWhenDoneRPC& rpc,
                {{service_name}}{{interface.name}}NotifyWhenDoneRPC::Request& request) -> asio::awaitable<void> {
                try {
                    co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_notify_when_done_rpc_handler(rpc, request);
                } catch (const std::exception& e) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, e.what());
                } catch (...) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, "Unknown exception caught");
                }
                co_return;
            },
            RethrowFirstArg{});
        
        {% elif interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_svc,
            [this]({{service_name}}{{interface.name}}RPC& rpc) -> asio::awaitable<void> {
                try {
                    co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc);
                } catch (const std::exception& e) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, e.what());
                } catch (...) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, "Unknown exception caught");
                }
                co_return;
            },
            RethrowFirstArg{});
        {% else %}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_svc,
            [this]({{service_name}}{{interface.name}}RPC& rpc, {{grpc.package}}::{{interface.input}}& request) -> asio::awaitable<void> {
                try {
                    co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc, request);
                } catch (const std::exception& e) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, e.what());
                } catch (...) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, "Unknown exception caught");
                }
                co_return;
            },
            RethrowFirstArg{});
        {% endif -%}
        {%- endfor -%}
        {%- endfor -%}
#else
        {%- for service_name in grpc.interface -%}
        {% for interface in grpc.interface[service_name] %}
        {% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_svc,
            [this]({{service_name}}{{interface.name}}RPC& rpc) -> asio::awaitable<void> {
                try {
                    co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc);
                } catch (const std::exception& e) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, e.what());
                } catch (...) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, "Unknown exception caught");
                }
                co_return;
            },
            RethrowFirstArg{});
        {% else -%}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_svc,
            [this]({{service_name}}{{interface.name}}RPC& rpc, {{grpc.package}}::{{interface.input}}& request) -> asio::awaitable<void> {
                try {
                    co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc, request);
                } catch (const std::exception& e) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, e.what());
                } catch (...) {
                    m_log(LogLevel::Error, extractFilename(__FILE__), __LINE__, "Unknown exception caught");
                }
                co_return;
            },
            RethrowFirstArg{});
        {% endif -%}
        {% endfor %}
        {% endfor %}
#endif
    }

    {{grpc.server_class_name}}Config m_config;
    std::function<void(LogLevel, std::string_view, int, std::string)> m_log = [](auto, auto, auto, auto) {};
    std::function<void(grpc::ServerBuilder&)> m_add_channel_argument;

    {% for service_name in grpc.interface -%}
    {% for interface in grpc.interface[service_name] -%}
    {% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
    std::function<asio::awaitable<void>({{service_name}}{{interface.name}}RPC&)> m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler;
    {% else -%}
    std::function<asio::awaitable<void>({{service_name}}{{interface.name}}RPC&, {{grpc.package}}::{{interface.input}}&)> m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler;
    {% endif -%}
    {% endfor -%}
    {% endfor -%}

#if USE_GRPC_NOTIFY_WHEN_DONE
    {% for service_name in grpc.interface %}
    {% for interface in grpc.interface[service_name] %}
    {% if interface.type=='server-streaming-rpc' %}
    std::function<
        asio::awaitable<void>({{service_name}}{{interface.name}}NotifyWhenDoneRPC&, 
        {{service_name}}{{interface.name}}NotifyWhenDoneRPC::Request&)> m_{{service_name|to_snake}}_{{interface.name|to_snake}}_notify_when_done_rpc_handler;
    {% else %}
    {% endif %}
    {% endfor %}
    {% endfor %}
#endif

    std::function<std::shared_ptr<grpc::ServerCredentials>()> m_create_server_credentials;
    {% for service_name in grpc.interface -%}
    std::unique_ptr<{{grpc.package}}::{{service_name}}::AsyncService> m_{{service_name|to_snake}}_svc;
    {% endfor -%}
    std::unique_ptr<grpc::Server> m_server_ptr;
    std::vector<std::shared_ptr<agrpc::GrpcContext>> m_grpc_contexts;
    std::vector<std::thread> m_threads;
};

} // {{grpc.namespace}}

