/**
 *
 *  @file {{grpc.out_file | get_filename }}
 *  @author fantasy-peak
 *  Auto generate by https://github.com/fantasy-peak/cpp-grpc-auto-gen.git
 *  Copyright 2024, fantasy-peak. All rights reserved.
 *  Use of this source code is governed by a MIT license
 *  that can be found in the License file.
 *
 */

#pragma once

#include <functional>
#include <memory>
#include <mutex>
#include <thread>
#include <utility>
#include <vector>
#include <shared_mutex>

#ifdef USE_BOOST_CIRCULAR_BUFFER
#include <boost/circular_buffer.hpp>
#endif
#ifdef AGRPC_BOOST_ASIO
#include <boost/asio.hpp>
#include <boost/asio/awaitable.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/experimental/awaitable_operators.hpp>
#include <boost/asio/experimental/concurrent_channel.hpp>
#include <boost/asio/post.hpp>
#include <boost/asio/use_awaitable.hpp>
#include <boost/system/detail/error_code.hpp>
#else
#include <asio.hpp>
#include <asio/awaitable.hpp>
#include <asio/detached.hpp>
#include <asio/experimental/awaitable_operators.hpp>
#include <asio/experimental/concurrent_channel.hpp>
#include <asio/post.hpp>
#include <asio/use_awaitable.hpp>
#include <system/detail/error_code.hpp>
#endif

{% for name in grpc.include_grpc_files -%}
#include <{{ name }}>
{% endfor -%}
#include <health.grpc.pb.h>
#include <health.pb.h>

#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/ext/proto_server_reflection_plugin.h>

#include <agrpc/asio_grpc.hpp>
#include <agrpc/health_check_service.hpp>



namespace {{grpc.namespace}} {

#ifdef AGRPC_BOOST_ASIO
namespace asio = boost::asio;
#endif

struct RethrowFirstArg {
    template <class... T>
    void operator()(std::exception_ptr ep, T&&...) {
        if (ep) {
            std::rethrow_exception(ep);
        }
    }

    template <class... T>
    void operator()(T&&...) {}
};

template <typename T>
struct Message {
    std::shared_ptr<T> info_ptr;
    uint64_t seq_no;
};

template <typename T>
class Topic final : public std::enable_shared_from_this<Topic<T>> {
  public:
#ifdef USE_BOOST_CIRCULAR_BUFFER
    explicit Topic(const std::string& topic, std::size_t count)
        : m_topic(topic), m_buffer(count) {
    }
#else
    explicit Topic(const std::string& topic, std::size_t count)
        : m_topic(topic) {
        m_buffer.reserve(count);
    }
#endif

    ~Topic() {
        clear();
    }

    Topic(const Topic&) = delete;
    Topic(Topic&&) = delete;
    Topic& operator=(const Topic&) = delete;
    Topic& operator=(Topic&&) = delete;

    struct ScopedConn {
        ScopedConn(std::weak_ptr<Topic<T>> topic_ptr, uint64_t call_id)
            : m_topic_ptr(std::move(topic_ptr)), m_call_id(call_id) {
        }

        ScopedConn(const ScopedConn&) = delete;
        ScopedConn(ScopedConn&&) = delete;
        ScopedConn& operator=(const ScopedConn&) = delete;
        ScopedConn& operator=(ScopedConn&&) = delete;

        ~ScopedConn() {
            if (m_reset)
                return;
            if (auto sp = m_topic_ptr.lock())
                sp->erase(m_call_id);
        }

        auto callId() {
            return m_call_id;
        }

        auto reset() {
            m_reset = true;
        }

        std::weak_ptr<Topic<T>> m_topic_ptr;
        uint64_t m_call_id;
        bool m_reset{false};
    };

    void setNoticeCallback(auto& cb) {
        std::lock_guard lk(m_mutex);
        m_notice_cb = cb;
    }

    void recover(const std::vector<std::shared_ptr<Message<T>>>& vec) {
        std::lock_guard lk(m_mutex);
        if (vec.empty())
            return;
        m_buffer.insert(m_buffer.end(), vec.begin(), vec.end());
        m_seq_no = vec.back()->seq_no;
        m_seq_no++;
    }

    void publish(std::shared_ptr<T> ptr) {
        std::lock_guard lk(m_mutex);
        auto message_ptr =
            std::make_shared<Message<T>>(std::move(ptr), m_seq_no++);
        m_buffer.push_back(std::move(message_ptr));
        auto& buffer_ptr = m_buffer.back();
        if (m_notice_cb)
            m_notice_cb(m_topic, buffer_ptr);
        for (auto& [call_id, sig] : m_sig)
            sig(buffer_ptr);
    }

    auto subscribe(uint64_t seq_no,
                   std::function<void(const std::shared_ptr<Message<T>>&)> cb) {
        std::lock_guard lk(m_mutex);
        return findAndSubscribe(seq_no, std::move(cb));
    }

    auto resubscribe(
        std::optional<uint64_t> call_id,
        uint64_t seq_no,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb) {
        std::lock_guard lk(m_mutex);
        if (call_id.has_value())
            m_sig.erase(call_id.value());
        return findAndSubscribe(seq_no, std::move(cb));
    }

#ifdef USE_BOOST_CIRCULAR_BUFFER
    auto subscribe(
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        const std::function<std::vector<std::shared_ptr<Message<T>>>(
            const boost::circular_buffer<std::shared_ptr<Message<T>>>&)>&
            filter) {
#else
    auto subscribe(
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        const std::function<std::vector<std::shared_ptr<Message<T>>>(
            const std::vector<std::shared_ptr<Message<T>>>&)>& filter) {
#endif
        std::lock_guard lk(m_mutex);
        auto scoped_connection_ptr = std::make_unique<ScopedConn>(this->shared_from_this(), m_call_id);
        m_sig.emplace(m_call_id++, std::move(cb));
        auto msg_vec = filter(m_buffer);
        return std::make_tuple(std::move(msg_vec), std::move(scoped_connection_ptr));
    }

#ifdef USE_BOOST_CIRCULAR_BUFFER
    auto resubscribe(
        std::optional<uint64_t> call_id,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        const std::function<std::vector<std::shared_ptr<Message<T>>>(
            const boost::circular_buffer<std::shared_ptr<Message<T>>>&)>&
            filter) {
#else
    auto resubscribe(
        std::optional<uint64_t> call_id,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        const std::function<std::vector<std::shared_ptr<Message<T>>>(
            const std::vector<std::shared_ptr<Message<T>>>&)>& filter) {
#endif
        std::lock_guard lk(m_mutex);
        if (call_id.has_value())
            m_sig.erase(call_id.value());
        auto scoped_connection_ptr = std::make_unique<ScopedConn>(this->shared_from_this(), m_call_id);
        m_sig.emplace(m_call_id++, std::move(cb));
        auto msg_vec = filter(m_buffer);
        return std::make_tuple(std::move(msg_vec), std::move(scoped_connection_ptr));
    }

    void clear() {
        std::lock_guard lk(m_mutex);
        m_sig.clear();
        m_buffer.clear();
    }

  private:
    auto findAndSubscribe(uint64_t seq_no, std::function<void(const std::shared_ptr<Message<T>>&)> cb) {
        auto scoped_connection_ptr = std::make_unique<ScopedConn>(this->shared_from_this(), m_call_id);
        m_sig.emplace(m_call_id++, std::move(cb));
        std::vector<std::shared_ptr<Message<T>>> msg_vec;
        auto it = std::ranges::find_if(m_buffer, [&](auto& ptr) {
            return seq_no == ptr->seq_no;
        });
        if (it == m_buffer.end()) {
            auto& front = m_buffer.front();
            if (seq_no < front->seq_no) {
                it = m_buffer.begin();
            } else {
                return std::make_tuple(std::move(msg_vec), std::move(scoped_connection_ptr));
            }
        }
        msg_vec.reserve(std::distance(it, m_buffer.end()));
        std::for_each(it, m_buffer.end(), [&](auto& ptr) {
            msg_vec.emplace_back(ptr);
        });
        return std::make_tuple(std::move(msg_vec), std::move(scoped_connection_ptr));
    }

    void erase(uint64_t call_id) {
        std::lock_guard lk(m_mutex);
        m_sig.erase(call_id);
    }

    std::string m_topic;
#ifdef USE_BOOST_CIRCULAR_BUFFER
    boost::circular_buffer<std::shared_ptr<Message<T>>> m_buffer;
#else
    std::vector<std::shared_ptr<Message<T>>> m_buffer;
#endif
    std::mutex m_mutex;
    std::unordered_map<uint64_t, std::function<void(const std::shared_ptr<Message<T>>&)>> m_sig;
    uint64_t m_call_id{0};
    uint64_t m_seq_no{0};
    std::function<void(const std::string&, const std::shared_ptr<Message<T>>&)> m_notice_cb;
};

template <typename T>
class PubSubService final {
  public:
    explicit PubSubService(std::size_t count = 1000000) : m_size(count) {
    }

    ~PubSubService() {
        std::unique_lock<std::shared_mutex> lock(m_mutex);
        m_topic_map.clear();
    }

    PubSubService(const PubSubService&) = delete;
    PubSubService(PubSubService&&) = delete;
    PubSubService& operator=(const PubSubService&) = delete;
    PubSubService& operator=(PubSubService&&) = delete;

    void setNoticeCallback(const std::function<void(const std::string&, const std::shared_ptr<Message<T>>&)>& cb) {
        m_notice_cb = cb;
    }

    void recover(std::function<std::unordered_map<std::string, std::vector<std::shared_ptr<Message<T>>>>()> cb) {
        auto data = cb();
        for (auto& [topic, vec] : data) {
            auto topic_ptr = getTopicPtr(topic);
            topic_ptr->recover(vec);
        }
    }

    decltype(auto) subscribe(
        const std::string& topic,
        uint64_t seq_no,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb) {
        auto topic_ptr = getTopicPtr(topic);
        return topic_ptr->subscribe(seq_no, std::move(cb));
    }

    decltype(auto) resubscribe(
        std::optional<uint64_t> call_id,
        const std::string& topic,
        uint64_t seq_no,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb) {
        auto topic_ptr = getTopicPtr(topic);
        return topic_ptr->resubscribe(std::move(call_id), seq_no, std::move(cb));
    }

#ifdef USE_BOOST_CIRCULAR_BUFFER
    decltype(auto) subscribe(
        const std::string& topic,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        std::function<std::vector<std::shared_ptr<Message<T>>>(const boost::circular_buffer<std::shared_ptr<Message<T>>>&)> filter) {
#else
    decltype(auto) subscribe(
        const std::string& topic,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        std::function<std::vector<std::shared_ptr<Message<T>>>(const std::vector<std::shared_ptr<Message<T>>>&)> filter) {
#endif
        auto topic_ptr = getTopicPtr(topic);
        return topic_ptr->subscribe(std::move(cb), filter);
    }

#ifdef USE_BOOST_CIRCULAR_BUFFER
    decltype(auto) resubscribe(
        std::optional<uint64_t> call_id,
        const std::string& topic,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        std::function<std::vector<std::shared_ptr<Message<T>>>(const boost::circular_buffer<std::shared_ptr<Message<T>>>&)> filter) {
#else
    decltype(auto) resubscribe(
        std::optional<uint64_t> call_id,
        const std::string& topic,
        std::function<void(const std::shared_ptr<Message<T>>&)> cb,
        std::function<std::vector<std::shared_ptr<Message<T>>>(const std::vector<std::shared_ptr<Message<T>>>&)> filter) {
#endif
        auto topic_ptr = getTopicPtr(topic);
        return topic_ptr->resubscribe(std::move(call_id), std::move(cb), filter);
    }

    template <typename Input>
        requires std::is_same_v<std::decay_t<Input>, T>
    void publish(const std::string& topic, Input&& in) {
        auto topic_ptr = getTopicPtr(topic);
        topic_ptr->publish(std::make_shared<std::decay_t<Input>>(std::forward<Input>(in)));
        return;
    }

  private:
    std::shared_ptr<Topic<T>> getTopicPtr(const std::string& topic) {
        std::shared_ptr<Topic<T>> topic_ptr;
        {
            std::shared_lock<std::shared_mutex> lock(m_mutex);
            auto iter = m_topic_map.find(topic);
            if (iter != m_topic_map.end()) {
                topic_ptr = iter->second;
                return topic_ptr;
            }
        }
        std::unique_lock<std::shared_mutex> lock(m_mutex);
        auto iter = m_topic_map.find(topic);
        if (iter != m_topic_map.end()) {
            topic_ptr = iter->second;
            return topic_ptr;
        }
        topic_ptr = std::make_shared<Topic<T>>(topic, m_size);
        if (m_notice_cb)
            topic_ptr->setNoticeCallback(m_notice_cb);
        m_topic_map[topic] = topic_ptr;
        return topic_ptr;
    }

    std::size_t m_size;
    std::unordered_map<std::string, std::shared_ptr<Topic<T>>> m_topic_map;
    mutable std::shared_mutex m_mutex;
    std::function<void(const std::string&, const std::shared_ptr<Message<T>>&)> m_notice_cb;
};

struct GrpcConfig {
    std::string host;
    int32_t thread_count{2};
    int32_t keepalive_time_ms{10000};
    int32_t keepalive_timeout_ms{10000};
    int32_t keepalive_permit_without_calls{1};
    int32_t http2_max_pings_without_data{0};
    int32_t http2_min_sent_ping_interval_without_data_ms{10000};
    int32_t http2_min_recv_ping_interval_without_data_ms{5000};
    std::optional<int32_t> min_pollers;
    std::optional<int32_t> max_pollers;
};

template <auto RequestRPC>
using AwaitableServerRPC = asio::use_awaitable_t<>::as_default_on_t<agrpc::ServerRPC<RequestRPC>>;
{% for service_name in grpc.interface -%}
using {{service_name}}Service = {{grpc.package}}::{{service_name}}::AsyncService;
{% for interface in grpc.interface[service_name] -%}
using {{service_name}}{{interface.name}}RPC = AwaitableServerRPC<&{{service_name}}Service::Request{{interface.name}}>;
{% endfor -%}
{% endfor -%}

#ifdef AGRPC_BOOST_ASIO
template <typename T>
using ConcurrentChannel = asio::experimental::concurrent_channel<void(boost::system::error_code, std::shared_ptr<Message<T>>)>;
#else
template <typename T>
using ConcurrentChannel = asio::experimental::concurrent_channel<void(asio::error_code, std::shared_ptr<Message<T>>)>;
#endif

class {{grpc.class_name}} final {
public:
    {{grpc.class_name}}(GrpcConfig config)
        : m_config(std::move(config)) {
    }
    ~{{grpc.class_name}}() = default;

    {{grpc.class_name}}(const {{grpc.class_name}}&) = delete;
    {{grpc.class_name}}& operator=(const {{grpc.class_name}}&) = delete;
    {{grpc.class_name}}({{grpc.class_name}}&&) = delete;
    {{grpc.class_name}}& operator=({{grpc.class_name}}&&) = delete;

    void start() {
        checkCallback();
        grpc::ServerBuilder builder;
        for (int i = 0; i < m_config.thread_count; i++) {
            m_grpc_contexts.emplace_back(std::make_shared<agrpc::GrpcContext>(builder.AddCompletionQueue()));
        }
        auto creds = grpc::InsecureServerCredentials();
        if (m_create_server_credentials)
            creds = m_create_server_credentials();
        builder.AddListeningPort(m_config.host, creds);
        grpc::reflection::InitProtoReflectionServerBuilderPlugin();

        {% for service_name in grpc.interface -%}
        m_{{service_name|to_snake}}_service = std::make_unique<{{service_name}}Service>();
        builder.RegisterService(m_{{service_name|to_snake}}_service.get());
        {% endfor %}

        // https://stackoverflow.com/questions/64297617/grpc-c-how-to-detect-client-disconnected-in-async-server
        grpc::ChannelArguments args;
        // keepalive
        builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_TIME_MS, m_config.keepalive_time_ms);
        builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_TIMEOUT_MS, m_config.keepalive_timeout_ms);
        builder.AddChannelArgument(GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS, m_config.keepalive_permit_without_calls);
        builder.AddChannelArgument(GRPC_ARG_HTTP2_MAX_PINGS_WITHOUT_DATA, m_config.http2_max_pings_without_data);
        builder.AddChannelArgument(GRPC_ARG_HTTP2_MIN_SENT_PING_INTERVAL_WITHOUT_DATA_MS, m_config.http2_min_sent_ping_interval_without_data_ms);
        builder.AddChannelArgument(GRPC_ARG_HTTP2_MIN_RECV_PING_INTERVAL_WITHOUT_DATA_MS, m_config.http2_min_recv_ping_interval_without_data_ms);

        if (m_config.min_pollers.has_value())
            builder.SetSyncServerOption(grpc::ServerBuilder::MIN_POLLERS, m_config.min_pollers.value());
        if (m_config.max_pollers.has_value())
            builder.SetSyncServerOption(grpc::ServerBuilder::MAX_POLLERS, m_config.max_pollers.value());

        agrpc::add_health_check_service(builder);
        m_server_ptr = builder.BuildAndStart();
        agrpc::start_health_check_service(*m_server_ptr, *m_grpc_contexts[0]);

        for (int32_t i = 0; i < m_config.thread_count; ++i) {
            m_threads.emplace_back([this, i] {
                auto& grpc_context = *m_grpc_contexts[i];
                registerHandler(grpc_context);
                grpc_context.run();
            });
        }
    }

    void stop() {
        if (m_grpc_contexts.empty())
            return;
        asio::post(*m_grpc_contexts[0], [&] { m_server_ptr->Shutdown(); });
        for (auto& thread : m_threads)
            thread.join();
        m_grpc_contexts.clear();
        m_threads.clear();
    }

    void setCreateSslServerCredentialsCallback(auto cb) {
        m_create_server_credentials = std::move(cb);
    }
    {% for service_name in grpc.interface -%}
    {% for interface in grpc.interface[service_name] -%}
    void set{{service_name}}{{interface.name}}RpcCallback(auto cb) {
        m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler = std::move(cb);
    }
    {% endfor -%}
    {% endfor -%}

private:
    void checkCallback() {
        {% for service_name in grpc.interface -%}
        {% for interface in grpc.interface[service_name] -%}
            if (!m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler)
                throw std::runtime_error("not call set{{service_name}}{{interface.name}}RpcCallback");
        {% endfor -%}
        {% endfor -%}
    }

    void registerHandler(auto& grpc_context) {
        {% for service_name in grpc.interface %}
        {% for interface in grpc.interface[service_name] %}
        {% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_service,
            [this]({{service_name}}{{interface.name}}RPC& rpc) -> asio::awaitable<void> {
                co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc);
                co_return;
            },
            RethrowFirstArg{});
        {% else -%}
        agrpc::register_awaitable_rpc_handler<{{service_name}}{{interface.name}}RPC>(
            grpc_context,
            *m_{{service_name|to_snake}}_service,
            [this]({{service_name}}{{interface.name}}RPC& rpc, {{grpc.package}}::{{interface.input}}& request) -> asio::awaitable<void> {
                co_await m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler(rpc, request);
                co_return;
            },
            RethrowFirstArg{});
        {% endif -%}
        {% endfor %}
        {% endfor %}
    }

    GrpcConfig m_config;
    {% for service_name in grpc.interface -%}
    {% for interface in grpc.interface[service_name] -%}
    {% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
    std::function<asio::awaitable<void>({{service_name}}{{interface.name}}RPC&)> m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler;
    {% else -%}
    std::function<asio::awaitable<void>({{service_name}}{{interface.name}}RPC&, {{grpc.package}}::{{interface.input}}&)> m_{{service_name|to_snake}}_{{interface.name|to_snake}}_rpc_handler;
    {% endif -%}
    {% endfor -%}
    {% endfor -%}
    std::function<std::shared_ptr<grpc::ServerCredentials>()> m_create_server_credentials;
    {% for service_name in grpc.interface -%}
    std::unique_ptr<{{service_name}}Service> m_{{service_name|to_snake}}_service;
    {% endfor -%}
    std::unique_ptr<grpc::Server> m_server_ptr;
    std::vector<std::shared_ptr<agrpc::GrpcContext>> m_grpc_contexts;
    std::vector<std::thread> m_threads;
};

} // {{grpc.namespace}}

/* example

#ifndef AGRPC_BOOST_ASIO
#define AGRPC_BOOST_ASIO 1
#endif

#ifndef USE_BOOST_CIRCULAR_BUFFER
#define USE_BOOST_CIRCULAR_BUFFER 1
#endif

#include <{{grpc.out_file | get_filename }}>

int main() {
    {{grpc.namespace}}::GrpcConfig config{
        .host = "0.0.0.0:5566",
        .thread_count = 1,
        .keepalive_time_ms = 10000,
        .keepalive_timeout_ms = 10000,
        .keepalive_permit_without_calls = 1,
        .http2_max_pings_without_data = 0,
        .http2_min_sent_ping_interval_without_data_ms = 10000,
        .http2_min_recv_ping_interval_without_data_ms = 5000,
        .min_pollers = 2,
        .max_pollers = 4,
    };
    auto m_grpc_server = std::make_unique<{{grpc.namespace}}::{{grpc.class_name}}>(config);
    namespace asio = boost::asio;

    {% for service_name in grpc.interface -%}
    {% for interface in grpc.interface[service_name] -%}
    {% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' -%}
    m_grpc_server->set{{service_name}}{{interface.name}}RpcCallback(
        [] ({{grpc.namespace}}::{{service_name}}{{interface.name}}RPC& rpc) -> asio::awaitable<void> {
            (void)rpc;
            co_return;
        });
    {% else -%}
    m_grpc_server->set{{service_name}}{{interface.name}}RpcCallback(
        [] ({{grpc.namespace}}::{{service_name}}{{interface.name}}RPC& rpc, {{grpc.package}}::{{interface.input}}& request) -> asio::awaitable<void> {
            (void)rpc;
            (void)request;
            co_return;
        });
    {% endif -%}
    {% endfor -%}
    {% endfor -%}

    m_grpc_server->start();
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    m_grpc_server->stop();

    return 0;
}

//-----------------------------------------------------------
{% for service_name in grpc.interface -%}
{% for interface in grpc.interface[service_name] -%}
{% if interface.type=='bidirectional-streaming-rpc' or interface.type=='client-streaming-rpc' %}
asio::awaitable<void> {{interface.name | to_lower_camel}}({{grpc.namespace}}::{{service_name}}{{interface.name}}RPC& rpc){
    (void)rpc;
    co_return;
}
m_grpc_server->set{{service_name}}{{interface.name}}RpcCallback(std::bind_front(&Test::{{interface.name | to_lower_camel}}, this));
{% else %}
asio::awaitable<void> {{interface.name | to_lower_camel}}({{grpc.namespace}}::{{service_name}}{{interface.name}}RPC& rpc, {{grpc.package}}::{{interface.input}}& request) {
    (void)rpc;
    co_return;
}
m_grpc_server->set{{service_name}}{{interface.name}}RpcCallback(std::bind_front(&Test::{{interface.name | to_lower_camel}}, this));

{% endif %}
{% endfor -%}
{% endfor -%}

*/
