/**
 *
 *  @author fantasy-peak
 *  Auto generate by https://github.com/fantasy-peak/cpp-grpc-auto-gen.git
 *  Copyright 2024, fantasy-peak. All rights reserved.
 *  Use of this source code is governed by a MIT license
 *  that can be found in the License file.
 *
 */

#include <thread>

#include <spdlog/spdlog.h>
#include <{{grpc.out_client_file | get_filename }}>

namespace grpc_auto_gen {

namespace asio = boost::asio;

{% for service_name in grpc.interface -%}
{% for interface in grpc.interface[service_name] -%}
{% if interface.type=='server-streaming-rpc' -%}
asio::awaitable<void> make{{interface.name}}Request(agrpc::GrpcContext& grpc_context, {{grpc.package}}::{{service_name}}::Stub& stub)  {
    using RPC = agrpc::ClientRPC<&{{grpc.package}}::{{service_name}}::Stub::PrepareAsync{{interface.name}}>;
    grpc::ClientContext client_context;
    client_context.set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));

    RPC rpc{grpc_context};
    rpc.context().set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));

    {{grpc.package}}::{{interface.input}} request;
    co_await rpc.start(stub, request);

    {{grpc.package}}::{{interface.output}} response;

    while (co_await rpc.read(response))
    {
        spdlog::info("ClientRPC: Recv Server streaming ");
    }

    const grpc::Status status = co_await rpc.finish();

    co_return;
}
{% elif interface.type=='client-streaming-rpc' %}

asio::awaitable<void> make{{interface.name}}Request(agrpc::GrpcContext& grpc_context, {{grpc.package}}::{{service_name}}::Stub& stub) {
    using RPC = agrpc::ClientRPC<&{{grpc.package}}::{{service_name}}::Stub::PrepareAsync{{interface.name}}>;
    RPC rpc{grpc_context};
    rpc.context().set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));

    {{grpc.package}}::{{interface.output}} response;
    const bool start_ok = co_await rpc.start(stub, response);


    // Optionally read initial metadata first. Otherwise it will be read along with the first write.
        const bool read_ok = co_await rpc.read_initial_metadata();

        // Send a message.
        {{grpc.package}}::{{interface.input}} request;
        const bool write_ok = co_await rpc.write(request);

        // Wait for the server to recieve all our messages and obtain the server's response + status.
        const grpc::Status status = co_await rpc.finish();
        auto ok = status.ok();

        spdlog::info("ClientRPC: Client streaming completed. Response");

    co_return;
}

{% elif interface.type=='unary-rpc' %}

asio::awaitable<void> make{{interface.name}}Request(agrpc::GrpcContext& grpc_context, {{grpc.package}}::{{service_name}}::Stub& stub) {
    using RPC = agrpc::ClientRPC<&{{grpc.package}}::{{service_name}}::Stub::PrepareAsync{{interface.name}}>;
    grpc::ClientContext client_context;
    client_context.set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));
    {{grpc.package}}::{{interface.input}} request;
    {{grpc.package}}::{{interface.output}} response;
    const auto status = co_await RPC::request(grpc_context, stub, client_context, request, response);
    co_return;
}

{% else -%}

asio::awaitable<void> make{{interface.name}}Request(agrpc::GrpcContext& grpc_context, {{grpc.package}}::{{service_name}}::Stub& stub) {
                    // bidirectional-streaming-rpc
                    using RPC = agrpc::ClientRPC<&{{grpc.package}}::{{service_name}}::Stub::PrepareAsync{{interface.name}}>;

                    RPC rpc{grpc_context};
                    rpc.context().set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));

                    if (!co_await rpc.start(stub))
                    {
                        // Channel is either permanently broken or transiently broken but with the fail-fast option.
                        co_return;
                    }

                    // Perform a request/response ping-pong.
                    {{grpc.package}}::{{interface.input}} request;
                    {{grpc.package}}::{{interface.output}} response;

                    // Reads and writes can be performed simultaneously.
                    using namespace asio::experimental::awaitable_operators;
                    auto [read_ok, write_ok] =
                        co_await (rpc.read(response, asio::use_awaitable) && rpc.write(request, asio::use_awaitable));

                    const grpc::Status status = co_await rpc.finish();
                }

{% endif -%}
{% endfor -%}
{% endfor %}

}  // namespace grpc_auto_gen

int main(int argc, const char** argv)
{
    const char* port = argc >= 2 ? argv[1] : "5566";
    const auto host = std::string("localhost:") + port;
    const auto thread_count = std::thread::hardware_concurrency();
    using namespace grpc_auto_gen;
    {% for service_name in grpc.interface -%}
    auto client = {{grpc.namespace}}::{{grpc.client_class_name}}::create(host, thread_count);
    client->setLogCallback([](std::string_view file, int line, std::string_view msg) {
        spdlog::info("file: {}, line: {}, msg: {}", file, line, msg);
    });
    {% for interface in grpc.interface[service_name] -%}
        client->{{interface.name | to_lower_camel}}(make{{interface.name}}Request);
    {% endfor %}

    {% endfor -%}
    return 0;
}